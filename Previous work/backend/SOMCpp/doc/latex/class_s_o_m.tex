\hypertarget{class_s_o_m}{}\doxysection{S\+OM Class Reference}
\label{class_s_o_m}\index{SOM@{SOM}}


Abstract \mbox{\hyperlink{class_s_o_m}{S\+OM}} Class.  




{\ttfamily \#include $<$S\+O\+M.\+hpp$>$}

Inheritance diagram for S\+OM\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_s_o_m}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_s_o_m_ab6c60f7b21dfb64433565f0e705cd4c2}{S\+OM}} (int \mbox{\hyperlink{class_s_o_m_ae4c38ba4370b2d07a5e5f8ffcbccc525}{t\+\_\+lim}}, int \mbox{\hyperlink{class_s_o_m_ab395187d6ff5ce1f29e8839eb7c7f8a3}{inp\+\_\+dim}})
\begin{DoxyCompactList}\small\item\em Abstract \mbox{\hyperlink{class_s_o_m}{S\+OM}} class constructor. \end{DoxyCompactList}\item 
virtual vector$<$ \mbox{\hyperlink{class_node}{Node}} $>$ \& \mbox{\hyperlink{class_s_o_m_a829f11f5690ba25ecdfb9ce178da6bf5}{get\+\_\+nodes}} ()=0
\begin{DoxyCompactList}\small\item\em Abstract getter method to return reference to vector of Nodes within the \mbox{\hyperlink{class_s_o_m}{S\+OM}}. \end{DoxyCompactList}\item 
virtual vector$<$ \mbox{\hyperlink{class_node}{Node}} $\ast$ $>$ \mbox{\hyperlink{class_s_o_m_a4d747648f683b597f9faf3272fbb7560}{neighbors}} (\mbox{\hyperlink{class_node}{Node}} \&best, int t)=0
\begin{DoxyCompactList}\small\item\em Abstract method to return a vector of neighbor Node$\ast$ for a given \mbox{\hyperlink{class_node}{Node}}. \end{DoxyCompactList}\item 
virtual double \mbox{\hyperlink{class_s_o_m_ae73f65ee9f36498824fed80503e24743}{neighbor\+\_\+multiplier}} (\mbox{\hyperlink{class_node}{Node}} \&best, \mbox{\hyperlink{class_node}{Node}} \&n2, int t)=0
\begin{DoxyCompactList}\small\item\em Abstract method to return a double multiplier. \end{DoxyCompactList}\item 
virtual double \mbox{\hyperlink{class_s_o_m_ac8a128d68a9aee434e855fb43579bf90}{learning\+\_\+rate}} (int t)=0
\begin{DoxyCompactList}\small\item\em Abstract method to return a double for learning rate. \end{DoxyCompactList}\item 
virtual double \mbox{\hyperlink{class_s_o_m_a7491a813a1fa3c5f95ed668554390d1c}{neighbor\+\_\+size}} (int t)=0
\begin{DoxyCompactList}\small\item\em Abstract function for neighborhood radius. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_s_o_m_a9aff218fb50949a8642f2843921b7afe}{node\+\_\+initialisation}} ()=0
\begin{DoxyCompactList}\small\item\em Abstract function for initialising feature space posiitons of all nodes. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{class_s_o_m_a9fc458793dad0a1246c68f7e0a90f519}{distance}} (const Vector\+Xd \&v1, const Vector\+Xd \&v2)
\begin{DoxyCompactList}\small\item\em Compute Euclidean distance between two vectors. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_s_o_m_ac1eb215c7a58eaefd4f1099fcb67071d}{stochastic\+\_\+train}} (vector$<$ Vector\+Xd $>$ \&datas, int batch\+\_\+size)
\begin{DoxyCompactList}\small\item\em Train \mbox{\hyperlink{class_s_o_m}{S\+OM}} on the given dataset in batches. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_s_o_m_a209520739ca36ae40dc43a056460b5be}{batch\+\_\+train}} (vector$<$ Vector\+Xd $>$ \&datas)
\begin{DoxyCompactList}\small\item\em Train \mbox{\hyperlink{class_s_o_m}{S\+OM}} on the given dataset in batches. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_node}{Node}} \mbox{\hyperlink{class_s_o_m_a7d4c11fa7fe6aca9ffaaabd92af8a705}{new\+\_\+node}} (const Vector\+Xd \&topo\+\_\+coord, const Vector\+Xd \&init\+\_\+pos=Vector\+Xd\{\})
\begin{DoxyCompactList}\small\item\em Create a \mbox{\hyperlink{class_node}{Node}} object with give topological coordinates and feature space position. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_node}{Node}} \& \mbox{\hyperlink{class_s_o_m_a81f80885ed912f7cac62dfb996443e0f}{find\+\_\+bmu}} (const Vector\+Xd \&inp\+\_\+vec)
\begin{DoxyCompactList}\small\item\em Method returning closest node to input vector by Euclidean distance (best matching unit, B\+MU). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{class_s_o_m_ae4c38ba4370b2d07a5e5f8ffcbccc525}{t\+\_\+lim}}
\begin{DoxyCompactList}\small\item\em Number of training iterations. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_s_o_m_ab395187d6ff5ce1f29e8839eb7c7f8a3}{inp\+\_\+dim}}
\begin{DoxyCompactList}\small\item\em Input dimension, number of attributes for dataset. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_s_o_m_ac9fdc6ac2d50356dd886c26781ddaf6e}{node\+\_\+num}}
\begin{DoxyCompactList}\small\item\em Count of nodes in \mbox{\hyperlink{class_s_o_m}{S\+OM}}, used for \mbox{\hyperlink{class_node}{Node}} id. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Abstract \mbox{\hyperlink{class_s_o_m}{S\+OM}} Class. 

This abstract \mbox{\hyperlink{class_s_o_m}{S\+OM}} class implements basic \mbox{\hyperlink{class_s_o_m}{S\+OM}} training, B\+MU and distance functions. It is inherited by \mbox{\hyperlink{class_s_o_m}{S\+OM}} implementations, such as \mbox{\hyperlink{class_map2d}{Map2d}}. Classes inheriting from this must define their own topology of node linkage as a node\textquotesingle{}s neighbors. They must also define learning rate, a neighborhood function and node initialisation. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_s_o_m_ab6c60f7b21dfb64433565f0e705cd4c2}\label{class_s_o_m_ab6c60f7b21dfb64433565f0e705cd4c2}} 
\index{SOM@{SOM}!SOM@{SOM}}
\index{SOM@{SOM}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{SOM()}{SOM()}}
{\footnotesize\ttfamily S\+O\+M\+::\+S\+OM (\begin{DoxyParamCaption}\item[{int}]{t\+\_\+lim,  }\item[{int}]{inp\+\_\+dim }\end{DoxyParamCaption})}



Abstract \mbox{\hyperlink{class_s_o_m}{S\+OM}} class constructor. 


\begin{DoxyParams}{Parameters}
{\em t\+\_\+lim} & Topology coordinate of node in \mbox{\hyperlink{class_s_o_m}{S\+OM}}. \\
\hline
{\em inp\+\_\+dim} & Unique node id number starting from 0 for a given \mbox{\hyperlink{class_s_o_m}{S\+OM}}. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_s_o_m_a209520739ca36ae40dc43a056460b5be}\label{class_s_o_m_a209520739ca36ae40dc43a056460b5be}} 
\index{SOM@{SOM}!batch\_train@{batch\_train}}
\index{batch\_train@{batch\_train}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{batch\_train()}{batch\_train()}}
{\footnotesize\ttfamily void S\+O\+M\+::batch\+\_\+train (\begin{DoxyParamCaption}\item[{vector$<$ Vector\+Xd $>$ \&}]{datas }\end{DoxyParamCaption})}



Train \mbox{\hyperlink{class_s_o_m}{S\+OM}} on the given dataset in batches. 

A variant of the standard \mbox{\hyperlink{class_s_o_m}{S\+OM}} training algorithm where all input vectors are trained on before updating weights of all nodes.


\begin{DoxyParams}{Parameters}
{\em datas} & Complete training dataset vector for batch train. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_s_o_m_a9fc458793dad0a1246c68f7e0a90f519}\label{class_s_o_m_a9fc458793dad0a1246c68f7e0a90f519}} 
\index{SOM@{SOM}!distance@{distance}}
\index{distance@{distance}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{distance()}{distance()}}
{\footnotesize\ttfamily double S\+O\+M\+::distance (\begin{DoxyParamCaption}\item[{const Vector\+Xd \&}]{v1,  }\item[{const Vector\+Xd \&}]{v2 }\end{DoxyParamCaption})}



Compute Euclidean distance between two vectors. 


\begin{DoxyParams}{Parameters}
{\em v1} & First vector. \\
\hline
{\em v2} & Second vector.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Euclidean distance between v1 and v2. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_s_o_m_a81f80885ed912f7cac62dfb996443e0f}\label{class_s_o_m_a81f80885ed912f7cac62dfb996443e0f}} 
\index{SOM@{SOM}!find\_bmu@{find\_bmu}}
\index{find\_bmu@{find\_bmu}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{find\_bmu()}{find\_bmu()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_node}{Node}} \& S\+O\+M\+::find\+\_\+bmu (\begin{DoxyParamCaption}\item[{const Vector\+Xd \&}]{inp\+\_\+vec }\end{DoxyParamCaption})}



Method returning closest node to input vector by Euclidean distance (best matching unit, B\+MU). 


\begin{DoxyParams}{Parameters}
{\em inp\+\_\+vec} & Vector for which B\+MU should be found.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Reference to \mbox{\hyperlink{class_node}{Node}} that is the best matching unit. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_s_o_m_a829f11f5690ba25ecdfb9ce178da6bf5}\label{class_s_o_m_a829f11f5690ba25ecdfb9ce178da6bf5}} 
\index{SOM@{SOM}!get\_nodes@{get\_nodes}}
\index{get\_nodes@{get\_nodes}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{get\_nodes()}{get\_nodes()}}
{\footnotesize\ttfamily virtual vector$<$\mbox{\hyperlink{class_node}{Node}}$>$\& S\+O\+M\+::get\+\_\+nodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Abstract getter method to return reference to vector of Nodes within the \mbox{\hyperlink{class_s_o_m}{S\+OM}}. 

\begin{DoxyReturn}{Returns}
Reference to vector of Nodes within the \mbox{\hyperlink{class_s_o_m}{S\+OM}}. 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_map2d_adce0f2a155f35f675aa81bf3074b6f2f}{Map2d}}.

\mbox{\Hypertarget{class_s_o_m_ac8a128d68a9aee434e855fb43579bf90}\label{class_s_o_m_ac8a128d68a9aee434e855fb43579bf90}} 
\index{SOM@{SOM}!learning\_rate@{learning\_rate}}
\index{learning\_rate@{learning\_rate}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{learning\_rate()}{learning\_rate()}}
{\footnotesize\ttfamily virtual double S\+O\+M\+::learning\+\_\+rate (\begin{DoxyParamCaption}\item[{int}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Abstract method to return a double for learning rate. 

Learning rate is a global multiplier for the amount of distance a \mbox{\hyperlink{class_node}{Node}} is updated by. It decreases over time.


\begin{DoxyParams}{Parameters}
{\em t} & Current iteration number. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Double learning rate multiplier value. 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_map2d_a967e45269d6512fc333a0930a6ab4b84}{Map2d}}.

\mbox{\Hypertarget{class_s_o_m_ae73f65ee9f36498824fed80503e24743}\label{class_s_o_m_ae73f65ee9f36498824fed80503e24743}} 
\index{SOM@{SOM}!neighbor\_multiplier@{neighbor\_multiplier}}
\index{neighbor\_multiplier@{neighbor\_multiplier}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{neighbor\_multiplier()}{neighbor\_multiplier()}}
{\footnotesize\ttfamily virtual double S\+O\+M\+::neighbor\+\_\+multiplier (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_node}{Node}} \&}]{best,  }\item[{\mbox{\hyperlink{class_node}{Node}} \&}]{n2,  }\item[{int}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Abstract method to return a double multiplier. 

This multiplier is used to update a neighbor\textquotesingle{}s feature-\/space position for given \mbox{\hyperlink{class_node}{Node}}. Distance multiplier is a function of the two nodes and the current iteration number. Implemented by the subclass.


\begin{DoxyParams}{Parameters}
{\em best} & \mbox{\hyperlink{class_node}{Node}} of interest. \\
\hline
{\em n2} & Neighbor \mbox{\hyperlink{class_node}{Node}} of best. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Double multiplier value. 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_map2d_ac56c860d8b7bb0181745486caedfad8a}{Map2d}}.

\mbox{\Hypertarget{class_s_o_m_a7491a813a1fa3c5f95ed668554390d1c}\label{class_s_o_m_a7491a813a1fa3c5f95ed668554390d1c}} 
\index{SOM@{SOM}!neighbor\_size@{neighbor\_size}}
\index{neighbor\_size@{neighbor\_size}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{neighbor\_size()}{neighbor\_size()}}
{\footnotesize\ttfamily virtual double S\+O\+M\+::neighbor\+\_\+size (\begin{DoxyParamCaption}\item[{int}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Abstract function for neighborhood radius. 

Used in neighbor distance multiplier computation and neighbor multipler.


\begin{DoxyParams}{Parameters}
{\em t} & Current iteration number.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Double of neighborhood radius 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_map2d_aaade795581feb08edb5c7ccb2664f4c2}{Map2d}}.

\mbox{\Hypertarget{class_s_o_m_a4d747648f683b597f9faf3272fbb7560}\label{class_s_o_m_a4d747648f683b597f9faf3272fbb7560}} 
\index{SOM@{SOM}!neighbors@{neighbors}}
\index{neighbors@{neighbors}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{neighbors()}{neighbors()}}
{\footnotesize\ttfamily virtual vector$<$\mbox{\hyperlink{class_node}{Node}}$\ast$$>$ S\+O\+M\+::neighbors (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_node}{Node}} \&}]{best,  }\item[{int}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Abstract method to return a vector of neighbor Node$\ast$ for a given \mbox{\hyperlink{class_node}{Node}}. 


\begin{DoxyParams}{Parameters}
{\em best} & \mbox{\hyperlink{class_node}{Node}} of interest. \\
\hline
{\em t} & Current iteration number. Used in neighbor\+\_\+multiplier to compute radius of neighborhood. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of neighboring Node$\ast$. 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_map2d_ad3fd041f8783025fb8fac35cbf75c10f}{Map2d}}.

\mbox{\Hypertarget{class_s_o_m_a7d4c11fa7fe6aca9ffaaabd92af8a705}\label{class_s_o_m_a7d4c11fa7fe6aca9ffaaabd92af8a705}} 
\index{SOM@{SOM}!new\_node@{new\_node}}
\index{new\_node@{new\_node}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{new\_node()}{new\_node()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_node}{Node}} S\+O\+M\+::new\+\_\+node (\begin{DoxyParamCaption}\item[{const Vector\+Xd \&}]{topo\+\_\+coord,  }\item[{const Vector\+Xd \&}]{init\+\_\+pos = {\ttfamily VectorXd\{\}} }\end{DoxyParamCaption})}



Create a \mbox{\hyperlink{class_node}{Node}} object with give topological coordinates and feature space position. 


\begin{DoxyParams}{Parameters}
{\em topo\+\_\+coord} & Topological coordiante to be set for new node. \\
\hline
{\em init\+\_\+pos} & Initial node position within the feature space.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
New \mbox{\hyperlink{class_node}{Node}} object. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_s_o_m_a9aff218fb50949a8642f2843921b7afe}\label{class_s_o_m_a9aff218fb50949a8642f2843921b7afe}} 
\index{SOM@{SOM}!node\_initialisation@{node\_initialisation}}
\index{node\_initialisation@{node\_initialisation}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{node\_initialisation()}{node\_initialisation()}}
{\footnotesize\ttfamily virtual void S\+O\+M\+::node\+\_\+initialisation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Abstract function for initialising feature space posiitons of all nodes. 

Initialise feature space posiitons of all nodes.

Currently performs randomised position initialisation. 

Implemented in \mbox{\hyperlink{class_map2d_ab66f9e34dd365b49d782f5ae79b56f57}{Map2d}}.

\mbox{\Hypertarget{class_s_o_m_ac1eb215c7a58eaefd4f1099fcb67071d}\label{class_s_o_m_ac1eb215c7a58eaefd4f1099fcb67071d}} 
\index{SOM@{SOM}!stochastic\_train@{stochastic\_train}}
\index{stochastic\_train@{stochastic\_train}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{stochastic\_train()}{stochastic\_train()}}
{\footnotesize\ttfamily void S\+O\+M\+::stochastic\+\_\+train (\begin{DoxyParamCaption}\item[{vector$<$ Vector\+Xd $>$ \&}]{datas,  }\item[{int}]{batch\+\_\+size }\end{DoxyParamCaption})}



Train \mbox{\hyperlink{class_s_o_m}{S\+OM}} on the given dataset in batches. 

A variant of the standard \mbox{\hyperlink{class_s_o_m}{S\+OM}} training algorithm where a randomly selected batch of input vectors are trained on before updating weights of all required nodes. Batch size can be set to 1 to simulate the basic \mbox{\hyperlink{class_s_o_m}{S\+OM}} training algorithm.


\begin{DoxyParams}{Parameters}
{\em datas} & Complete training dataset vector. \\
\hline
{\em batch\+\_\+size} & Size of batches to train in. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_s_o_m_ab395187d6ff5ce1f29e8839eb7c7f8a3}\label{class_s_o_m_ab395187d6ff5ce1f29e8839eb7c7f8a3}} 
\index{SOM@{SOM}!inp\_dim@{inp\_dim}}
\index{inp\_dim@{inp\_dim}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{inp\_dim}{inp\_dim}}
{\footnotesize\ttfamily int S\+O\+M\+::inp\+\_\+dim\hspace{0.3cm}{\ttfamily [protected]}}



Input dimension, number of attributes for dataset. 

\mbox{\Hypertarget{class_s_o_m_ac9fdc6ac2d50356dd886c26781ddaf6e}\label{class_s_o_m_ac9fdc6ac2d50356dd886c26781ddaf6e}} 
\index{SOM@{SOM}!node\_num@{node\_num}}
\index{node\_num@{node\_num}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{node\_num}{node\_num}}
{\footnotesize\ttfamily int S\+O\+M\+::node\+\_\+num\hspace{0.3cm}{\ttfamily [protected]}}



Count of nodes in \mbox{\hyperlink{class_s_o_m}{S\+OM}}, used for \mbox{\hyperlink{class_node}{Node}} id. 

\mbox{\Hypertarget{class_s_o_m_ae4c38ba4370b2d07a5e5f8ffcbccc525}\label{class_s_o_m_ae4c38ba4370b2d07a5e5f8ffcbccc525}} 
\index{SOM@{SOM}!t\_lim@{t\_lim}}
\index{t\_lim@{t\_lim}!SOM@{SOM}}
\doxysubsubsection{\texorpdfstring{t\_lim}{t\_lim}}
{\footnotesize\ttfamily int S\+O\+M\+::t\+\_\+lim\hspace{0.3cm}{\ttfamily [protected]}}



Number of training iterations. 

